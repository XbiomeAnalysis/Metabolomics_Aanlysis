# Network Analysis

## Introduction

> Estimating microbial association networks from high-throughput sequencing data is a common exploratory data analysis approach aiming at understanding the complex interplay of microbial communities in their natural habitat. Statistical network estimation workflows comprise several analysis steps, including methods for zero handling, data normalization and computing microbial associations. Since microbial interactions are likely to change between conditions, e.g. between healthy individuals and patients, identifying network differences between groups is often an integral secondary analysis step. 

NetCoMi (Network Construction and Comparison for Microbiome Data) [@peschel2021netcomi] provides functionality for constructing, analyzing, and comparing networks suitable for the application on microbial compositional data.

The following information is from [NetCoMi github](https://github.com/stefpeschel/NetCoMi).


**Association measures:**

-   Pearson coefficient
    ([`cor()`](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/cor)
    from `stats` package)
-   Spearman coefficient
    ([`cor()`](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/cor)
    from `stats` package)
-   Biweight Midcorrelation
    [`bicor()`](https://rdrr.io/cran/WGCNA/man/bicor.html) from `WGCNA`
    package


**Methods for zero replacement:**

-   Adding a predefined pseudo count
-   Multiplicative replacement
    ([`multRepl`](https://rdrr.io/cran/zCompositions/man/multRepl.html)
    from `zCompositions` package)
-   Modified EM alr-algorithm
    ([`lrEM`](https://rdrr.io/cran/zCompositions/man/lrEM.html) from
    `zCompositions` package)
-   Bayesian-multiplicative replacement
    ([`cmultRepl`](https://rdrr.io/cran/zCompositions/man/cmultRepl.html)
    from `zCompositions` package)

**Normalization methods:**

-   Total Sum Scaling (TSS) (own implementation)
-   Cumulative Sum Scaling (CSS) ([`cumNormMat`]() from `metagenomeSeq`
    package)
-   Common Sum Scaling (COM) (own implementation)
-   Rarefying ([`rrarefy`]() from `vegan` package)
-   Variance Stabilizing Transformation (VST)
    ([`varianceStabilizingTransformation`]() from `DESeq2` package)
-   Centered log-ratio (clr) transformation
    ([`clr()`](https://rdrr.io/github/zdk123/SpiecEasi/man/clr.html)
    from `SpiecEasi` package))

TSS, CSS, COM, VST, and the clr transformation are described in [Badri et al., 2020].


## Loading packages
```{r}
knitr::opts_chunk$set(warning = F)

library(dplyr)
library(tibble)
library(POMA)
library(ggplot2)
library(ggraph)
library(plotly)
library(SummarizedExperiment)

# installing package
# devtools::install_github("stefpeschel/NetCoMi", 
#                          dependencies = c("Depends", "Imports", "LinkingTo"),
#                          repos = c("https://cloud.r-project.org/",
#                                    BiocManager::repositories()))
# devtools::install_github("GraceYoon/SPRING", force = TRUE)
# devtools::install_github("zdk123/SpiecEasi", force = TRUE)
library(NetCoMi)
library(SPRING)
library(SpiecEasi)


# rm(list = ls())
options(stringsAsFactors = F)
options(future.globals.maxSize = 1000 * 1024^2)
```

## Importing data

The input data sets are from the previous chapter.
```{r}
se_filter <- readRDS("./dataset/POMA/se_filter.RDS")
```

## Data curation
```{r}
features_tab <- SummarizedExperiment::assay(se_filter) %>% 
  t()
features_tab[is.na(features_tab)] <- 0

head(features_tab)
```


## Associations Among Features

### Single network with Pearson correlation as association measure

Since Pearson correlations may lead to compositional effects when applied to sequencing data, we use the clr transformation as normalization method. Zero treatment is necessary in this case.

* InputData: numeric matrix. Can be a count matrix (rows are samples, columns are Features).
  
* Method to compute the associations between features (argument measure).
  
* Normalization method:

  - normMethod: clr
  
  - zeroMethod: multRepl
  
  - sparsMethod: threshold

A threshold of 0.3 is used as sparsification method, so that only OTUs with an absolute correlation greater than or equal to 0.3 are connected.


#### Building network model
```{r}
net_single <- netConstruct(features_tab,  
                           measure = "pearson",
                           normMethod = "clr", 
                           zeroMethod = "multRepl",
                           sparsMethod = "threshold", 
                           thresh = 0.3,
                           verbose = 3,
                           seed = 123)
```

#### Visualizing the network

* primary plot
```{r, fig.height=6, fig.width=8}
props_single <- netAnalyze(net_single, clustMethod = "cluster_fast_greedy")

plot(props_single, 
     nodeColor = "cluster", 
     nodeSize = "eigenvector",
     title1 = "Network on metabolomics with Pearson correlations", 
     showTitle = TRUE,
     cexTitle = 1.5)

legend(0.7, 1.1, cex = 1, title = "estimated correlation:", 
       legend = c("+","-"), lty = 1, lwd = 3, col = c("#009900","red"), 
       bty = "n", horiz = TRUE)
```


* improve the visualization by changing the following arguments:

  - `repulsion = 0.8`: Place the nodes further apart
  
  - `rmSingles = TRUE`: Single nodes are removed
  
  - `labelScale = FALSE` and `cexLabels = 1.6`: All labels have equal size and are enlarged to improve readability of small nodeâ€™s labels
  
  - `nodeSizeSpread = 3` (default is 4): Node sizes are more similar if the value is decreased. This argument (in combination with `cexNodes`) is useful to enlarge small nodes while keeping the size of big nodes.
  
```{r, fig.height=8, fig.width=12}
plot(props_single, 
     nodeColor = "cluster", 
     nodeSize = "eigenvector",
     repulsion = 0.8,
     rmSingles = TRUE,
     labelScale = FALSE,
     cexLabels = 1.6,
     nodeSizeSpread = 3,
     cexNodes = 2,
     title1 = "Network on metabolomics with Pearson correlations", 
     showTitle = TRUE,
     cexTitle = 1.5)

legend(0.7, 1.1, cex = 1.2, title = "estimated correlation:",
       legend = c("+","-"), lty = 1, lwd = 3, col = c("#009900","red"),
       bty = "n", horiz = TRUE)
```


### Single network with spearman correlation as association measure

#### Building network model
```{r}
net_single2 <- netConstruct(features_tab,  
                            measure = "spearman",
                            normMethod = "clr", 
                            zeroMethod = "multRepl",
                            sparsMethod = "threshold", 
                            thresh = 0.3,
                            verbose = 3,
                            seed = 123)
```


#### Visualizing the network
```{r, fig.height=8, fig.width=12}
props_single2 <- netAnalyze(net_single2, clustMethod = "cluster_fast_greedy")

plot(props_single2, 
     nodeColor = "cluster", 
     nodeSize = "eigenvector",
     repulsion = 0.8,
     rmSingles = TRUE,
     labelScale = FALSE,
     cexLabels = 1.6,
     nodeSizeSpread = 3,
     cexNodes = 2,
     title1 = "Network on metabolomics with Spearman correlations", 
     showTitle = TRUE,
     cexTitle = 1.5)

legend(0.7, 1.1, cex = 1.2, title = "estimated correlation:",
       legend = c("+","-"), lty = 1, lwd = 3, col = c("#009900","red"),
       bty = "n", horiz = TRUE)
```



### Single network with WGCNA (bicor) as association measure


Biweight Midcorrelation `bicor()` from WGCNA package.

#### Building network model
```{r}
net_single3 <- netConstruct(features_tab, 
                           measure = "bicor",
                           measurePar = list(use = "all.obs",
                                             maxPOutliers = 1,
                                             nThreads = 2),
                           filtTax = "highestVar",
                           filtTaxPar = list(highestVar = 50),
                           filtSamp = "totalReads",
                           filtSampPar = list(totalReads = 100),
                           dissFunc = "TOMdiss",
                           verbose = 3)
```

#### Visualizing the network
```{r, fig.height=8, fig.width=12}
props_single3 <- netAnalyze(net_single3, clustMethod = "cluster_fast_greedy")

plot(props_single3, 
     nodeColor = "cluster", 
     nodeSize = "eigenvector",
     repulsion = 0.8,
     rmSingles = TRUE,
     labelScale = FALSE,
     cexLabels = 1.6,
     nodeSizeSpread = 3,
     cexNodes = 2,
     title1 = "Network on metabolomics with WGCNA correlations", 
     showTitle = TRUE,
     cexTitle = 1.5)

legend(0.7, 1.1, cex = 1.2, title = "estimated correlation:",
       legend = c("+","-"), lty = 1, lwd = 3, col = c("#009900","red"),
       bty = "n", horiz = TRUE)
```


## Network comparison

Comparing two networks by **NetCoMi**.

### Data preparing
```{r}
group_names <- c("Mild", "Severe")

se_filter_subset <- se_filter[, se_filter$group %in% group_names]
se_filter_subset$group <- factor(as.character(se_filter_subset$group))
features_tab <- SummarizedExperiment::assay(se_filter_subset) %>% 
  t()
features_tab[is.na(features_tab)] <- 0

group_vector <- se_filter_subset$group
```

### Building network model
```{r}
net_group <- netConstruct(features_tab, 
                          group = group_vector, 
                          measure = "pearson",
                          normMethod = "clr", 
                          zeroMethod = "multRepl",
                          sparsMethod = "threshold", 
                          thresh = 0.3,
                          verbose = 3,
                          seed = 123)
```

### Network analysis
```{r}
props_group <- netAnalyze(net_group, 
                          centrLCC = FALSE,
                          avDissIgnoreInf = TRUE,
                          sPathNorm = FALSE,
                          clustMethod = "cluster_fast_greedy",
                          hubPar = c("degree", "between", "closeness"),
                          hubQuant = 0.9,
                          lnormFit = TRUE,
                          normDeg = FALSE,
                          normBetw = FALSE,
                          normClose = FALSE,
                          normEigen = FALSE)

summary(props_group)
```


### Visualizing the network
```{r, fig.height=10, fig.width=20}
plot(props_group, 
     sameLayout = TRUE, 
     layoutGroup = 1,
     rmSingles = "inboth", 
     nodeSize = "mclr", 
     labelScale = FALSE,
     cexNodes = 1, 
     cexLabels = 1.5,
     cexHubLabels = 2,
     cexTitle = 2,
     groupNames = group_names,
     hubBorderCol  = "gray40")

legend("bottom", title = "estimated association:", legend = c("+", "-"), 
       col = c("#009900","red"), inset = 0.04, cex = 3, lty = 1, lwd = 4, 
       bty = "n", horiz = TRUE)
```


### Quantitative network comparison
```{r}
comp_group <- netCompare(props_group, permTest = FALSE, verbose = FALSE)

summary(comp_group, 
        groupNames = group_names,
        showCentr = c("degree", "between", "closeness"), 
        numbNodes = 5)
```


## Systematic Information
```{r}
devtools::session_info()
```

