# Univariate Analysis

Univariate analysis explores each variable in a data set, separately and it uses traditional statistical methods on single variable to calculate the statistics, such as fold change, p-value, etc.


## Loading packages
```{r}
knitr::opts_chunk$set(warning = F)

library(dplyr)
library(tibble)
library(POMA)
library(ggplot2)
library(ggraph)
library(plotly)
library(SummarizedExperiment)

# rm(list = ls())
options(stringsAsFactors = F)
options(future.globals.maxSize = 1000 * 1024^2)
```

## Importing data

The input data sets are from the previous chapter.
```{r}
se_impute <- readRDS("./dataset/POMA/se_impute.RDS")
se_normalize <- readRDS("./dataset/POMA/se_normalize.RDS")
se_processed <- readRDS("./dataset/POMA/se_processed.RDS")
```


## Fold Change Analysis
```{r}
FoldChange <- function(object,
                       group_names,
                       fc_cutoff = 2,
                       cmp_type = 0, 
                       paired = FALSE) {
  
  features_tab <- SummarizedExperiment::assay(object) 
  metadata_tab <- SummarizedExperiment::colData(object)   
  
  metadata <- metadata_tab %>%
    data.frame() %>%
    dplyr::filter(group %in% group_names)
  profile <- features_tab[, pmatch(rownames(metadata), colnames(features_tab))]
  
  # make sure threshold is above 1
  fc_cutoff <- ifelse(fc_cutoff > 1, fc_cutoff, 1/fc_cutoff)
  max_cutoff <- fc_cutoff
  min_cutoff <- 1 / fc_cutoff
  
  GetFC <- function(x,
                    y,
                    cmpType, 
                    paired = FALSE) {

    # x = profile
    # y = metadata
    # cmpType = cmp_type
    # paired = paired    
    
    x <- t(x)
    colNames <- colnames(x)
    rowNames <- rownames(x)
    
    if (paired) { 
      # compute the average of paired FC (unit is pair)
      G1 <- x[which(y$group == group_names[1]), ]
      G2 <- x[which(y$group == group_names[2]), ]
      
      if (cmpType == 0) {
        fc.mat <- G1 - G2
      } else {
        fc.mat <- G2 - G1
      }
      fc.log <- apply(fc.mat, 2, mean)
      fc.all <- signif(2^fc.log, 5)
    } else {
      m1 <- colMeans(x[which(y$group == group_names[1]), ])
      m2 <- colMeans(x[which(y$group == group_names[2]), ])
        
      # create a named matrix of sig vars for display
      if (cmpType == 0) {
          ratio <- m1/m2
      } else {
          ratio <- m2/m1
      }
      
      fc.all <- signif(ratio, 5)
      ratio[ratio < 0] <- 0
      fc.log <- signif(log2(ratio), 5)
      fc.log[is.infinite(fc.log) & fc.log < 0] <- -99
      fc.log[is.infinite(fc.log) & fc.log > 0] <- 99
    }
    
    names(fc.all) <- names(fc.log) <- colnames(x)
    
    res <- list(fc.all = fc.all, fc.log = fc.log)
    return(res)
  }  
  
  res <- GetFC(profile, metadata, cmp_type, paired)
  fc.all <- res$fc.all
  fc.log <- res$fc.log
  
  inx.up <- fc.all > max_cutoff
  inx.down <- fc.all < min_cutoff
  names(inx.up) <- names(inx.down) <- names(fc.all)
  imp.inx <- inx.up | inx.down
  sig.mat <- cbind(fc.all[imp.inx, drop = F], fc.log[imp.inx, drop = F])
  colnames(sig.mat) <- c("Fold Change", "log2(FC)")
  
  # order by absolute log value (since symmetrical in pos and neg)
  inx.ord <- order(abs(sig.mat[, 2]), decreasing = T)
  sig.mat <- sig.mat[inx.ord, , drop = F]
  
  return(sig.mat)
}

FC_res <- FoldChange(
           object = se_normalize, 
           fc_cutoff = 2,
           group_names = c("Mild", "Moderate"),
           cmp_type = 0, 
           paired = FALSE)

head(FC_res)
```


## T Test
```{r}
group_names <- c("Mild", "Severe")

se_processed_subset <- se_processed[, se_processed$group %in% group_names]
se_processed_subset$group <- factor(as.character(se_processed_subset$group))
ttest_res <- PomaUnivariate(se_processed_subset, method = "ttest")
head(ttest_res)
```


## Wilcoxon Test
```{r}
wilcox_res <- PomaUnivariate(se_processed_subset, method = "mann")
head(wilcox_res)
```


## Limma Test
```{r}
Limma_res <- PomaLimma(se_processed_subset, contrast = paste(group_names, collapse = "-"), adjust = "fdr")
head(Limma_res)
```

## Volcano plot
```{r, fig.height=5, fig.width=6}
se_impute_subset <- se_impute[, se_impute$group %in% group_names]
se_impute_subset$group <- factor(as.character(se_impute_subset$group))

PomaVolcano(se_impute_subset, 
            pval = "raw",
            pval_cutoff = 0.1,
            log2FC = 0.2,
            xlim = 1,
            labels = TRUE,
            plot_title = TRUE)
```


## Correlation Heatmaps
```{r, fig.width=10, fig.height=10}
poma_cor <- PomaCorr(se_processed_subset, label_size = 8, coeff = 0.6)
poma_cor$correlations
```

* correlation plot
```{r, fig.width=10, fig.height=10}
poma_cor$corrplot
```

* Network
```{r, fig.width=10, fig.height=10}
poma_cor$graph
```


## glasso: this function will compute a Gaussian Graphical Model using the glmnet package
```{r, fig.width=10, fig.height=10}
PomaCorr(se_processed_subset, corr_type = "glasso", coeff = 0.6)$graph
```


## Systematic Information
```{r}
devtools::session_info()
```
